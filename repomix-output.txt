This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
gradle/
  wrapper/
    gradle-wrapper.properties
src/
  main/
    java/
      net/
        tockmod/
          chunk/
            ChunkFuseManager.java
          command/
            TockCommands.java
          config/
            ModConfig.java
          entity/
            SnailSpawnManager.java
          mixin/
            entity/
              MobMixin.java
              MobSpawnerMixin.java
            server/
              ServerChunkManagerMixin.java
              ServerTickSchedulerMixin.java
              ServerWorldMixin.java
          scheduler/
            SmartScheduler.java
          tick/
            NeuroTickController.java
          TockMod.java
          TockServerMod.java
    resources/
      fabric.mod.json
      tock.mixins.json
.gitignore
build.gradle
gradle.properties
gradlew
gradlew.bat
LICENSE
README.md
settings.gradle

================================================================
Files
================================================================

================
File: gradlew
================
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH="\\\"\\\""


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

================
File: gradlew.bat
================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

================
File: gradle/wrapper/gradle-wrapper.properties
================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14.2-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
mixin.debug.verbose=true

================
File: src/main/java/net/tockmod/chunk/ChunkFuseManager.java
================
package net.tockmod.chunk;

import net.minecraft.server.MinecraftServer;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.math.ChunkPos;
import net.tockmod.config.ModConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

public class ChunkFuseManager {
    private static final Logger LOGGER = LoggerFactory.getLogger("Tock/ChunkFuse");
    private final Map<ChunkPos, ChunkActivityData> chunkActivityMap = new ConcurrentHashMap<>();
    private final AtomicLong lastCleanupTime = new AtomicLong(0);
    private static final long CLEANUP_INTERVAL = 1000; // Cleanup every second

    public void onServerTickStart(MinecraftServer server) {
        if (!ModConfig.getInstance().chunkfuseEnabled) {
            return;
        }

        long currentTime = System.currentTimeMillis();
        
        // Periodic cleanup of old chunks
        if (currentTime - lastCleanupTime.get() > CLEANUP_INTERVAL) {
            int beforeSize = chunkActivityMap.size();
            cleanupInactiveChunks(currentTime);
            int afterSize = chunkActivityMap.size();
            if (beforeSize != afterSize) {
                LOGGER.info("Cleaned up {} inactive chunks ({} remaining)", beforeSize - afterSize, afterSize);
            }
            lastCleanupTime.set(currentTime);
        }
    }

    public void onServerTickEnd(MinecraftServer server) {
        // No-op for now
    }

    public void markChunkActive(ServerWorld world, ChunkPos pos) {
        if (!ModConfig.getInstance().chunkfuseEnabled) {
            return;
        }

        chunkActivityMap.compute(pos, (key, data) -> {
            if (data == null) {
                LOGGER.debug("New chunk activity detected at {}", pos);
                return new ChunkActivityData(System.currentTimeMillis());
            }
            data.lastActivityTime = System.currentTimeMillis();
            return data;
        });
    }

    public boolean isChunkCold(ChunkPos pos) {
        if (!ModConfig.getInstance().chunkfuseEnabled) {
            return false;
        }

        ChunkActivityData data = chunkActivityMap.get(pos);
        if (data == null) {
            LOGGER.debug("Chunk {} has no activity data, considered cold", pos);
            return true;
        }

        long inactiveTime = System.currentTimeMillis() - data.lastActivityTime;
        boolean isCold = inactiveTime > ModConfig.getInstance().chunkColdTimeout * 1000;
        if (isCold) {
            LOGGER.debug("Chunk {} is cold (inactive for {}ms)", pos, inactiveTime);
        }
        return isCold;
    }

    private void cleanupInactiveChunks(long currentTime) {
        chunkActivityMap.entrySet().removeIf(entry -> {
            long inactiveTime = currentTime - entry.getValue().lastActivityTime;
            boolean shouldRemove = inactiveTime > ModConfig.getInstance().chunkColdTimeout * 1000;
            if (shouldRemove) {
                LOGGER.debug("Removing inactive chunk {} (inactive for {}ms)", entry.getKey(), inactiveTime);
            }
            return shouldRemove;
        });
    }

    private static class ChunkActivityData {
        long lastActivityTime;

        ChunkActivityData(long lastActivityTime) {
            this.lastActivityTime = lastActivityTime;
        }
    }
}

================
File: src/main/java/net/tockmod/command/TockCommands.java
================
package net.tockmod.command;

import com.mojang.brigadier.CommandDispatcher;
import net.minecraft.server.command.CommandManager;
import net.minecraft.server.command.ServerCommandSource;
import net.minecraft.text.Text;
import net.tockmod.TockMod;
import net.tockmod.config.ModConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class TockCommands {
    private static final Logger LOGGER = LoggerFactory.getLogger("Tock/Commands");

    public static void register(CommandDispatcher<ServerCommandSource> dispatcher) {
        dispatcher.register(CommandManager.literal("tock")
            .then(CommandManager.literal("debug")
                .executes(context -> {
                    ServerCommandSource source = context.getSource();
                    TockMod mod = TockMod.getInstance();
                    
                    source.sendMessage(Text.literal("=== Tock Debug Information ==="));
                    source.sendMessage(Text.literal(String.format("Last Tick Time: %dms", mod.getNeuroTickController().getLastTickTime())));
                    source.sendMessage(Text.literal(String.format("Average Tick Time: %.2fms", mod.getNeuroTickController().getAverageTickTime())));
                    source.sendMessage(Text.literal(String.format("Over Budget: %b", mod.getNeuroTickController().isOverBudget())));
                    
                    // Add configuration status
                    source.sendMessage(Text.literal("\n=== Configuration Status ==="));
                    source.sendMessage(Text.literal(String.format("NeuroTick Enabled: %b", ModConfig.getInstance().neurotickEnabled)));
                    source.sendMessage(Text.literal(String.format("ChunkFuse Enabled: %b", ModConfig.getInstance().chunkfuseEnabled)));
                    source.sendMessage(Text.literal(String.format("SnailSpawn Enabled: %b", ModConfig.getInstance().snailspawnEnabled)));
                    source.sendMessage(Text.literal(String.format("Smart Scheduler Enabled: %b", ModConfig.getInstance().schedulerEnabled)));
                    
                    // Add performance metrics
                    source.sendMessage(Text.literal("\n=== Performance Metrics ==="));
                    source.sendMessage(Text.literal(String.format("Max Tick Time: %dms", ModConfig.getInstance().maxTickTime)));
                    source.sendMessage(Text.literal(String.format("Chunk Cold Timeout: %ds", ModConfig.getInstance().chunkColdTimeout)));
                    source.sendMessage(Text.literal(String.format("Max Spawns Per Tick: %d", ModConfig.getInstance().maxSpawnsPerTick)));
                    
                    return 1;
                }))
            .then(CommandManager.literal("profile")
                .executes(context -> {
                    ServerCommandSource source = context.getSource();
                    source.sendMessage(Text.literal("=== Tock Profiling Information ==="));
                    source.sendMessage(Text.literal("Profiling not implemented yet"));
                    return 1;
                }))
            .then(CommandManager.literal("heatmap")
                .executes(context -> {
                    ServerCommandSource source = context.getSource();
                    source.sendMessage(Text.literal("=== Tock Chunk Heatmap ==="));
                    source.sendMessage(Text.literal("Heatmap not implemented yet"));
                    return 1;
                }))
        );
    }
}

================
File: src/main/java/net/tockmod/config/ModConfig.java
================
package net.tockmod.config;

import me.shedaniel.autoconfig.ConfigData;
import me.shedaniel.autoconfig.annotation.Config;
import me.shedaniel.autoconfig.annotation.ConfigEntry;
import me.shedaniel.autoconfig.serializer.GsonConfigSerializer;
import me.shedaniel.cloth.clothconfig.shadowed.blue.endless.jankson.Comment;
import net.tockmod.TockMod;

@Config(name = TockMod.MOD_ID)
public class ModConfig implements ConfigData {
    @ConfigEntry.Category("neurotick")
    @Comment("Enable the NeuroTick system for tick budget management")
    public boolean neurotickEnabled = true;

    @ConfigEntry.Category("neurotick")
    @Comment("Maximum milliseconds per tick (default: 40ms for 20 TPS)")
    public int maxTickTime = 40;

    @ConfigEntry.Category("chunkfuse")
    @Comment("Enable the ChunkFuse system for chunk activity tracking")
    public boolean chunkfuseEnabled = true;

    @ConfigEntry.Category("chunkfuse")
    @Comment("Seconds of inactivity before a chunk is considered 'cold'")
    public int chunkColdTimeout = 30;

    @ConfigEntry.Category("snailspawn")
    @Comment("Enable the SnailSpawn system for controlled entity spawning")
    public boolean snailspawnEnabled = true;

    @ConfigEntry.Category("snailspawn")
    @Comment("Maximum entities that can spawn per tick")
    public int maxSpawnsPerTick = 10;

    @ConfigEntry.Category("scheduler")
    @Comment("Enable the Smart Scheduler system")
    public boolean schedulerEnabled = true;

    @ConfigEntry.Category("scheduler")
    @Comment("Enable preemptive cancellation of redundant updates")
    public boolean enablePreemptiveCancellation = true;

    private static ModConfig INSTANCE;

    public static void load() {
        if (INSTANCE == null) {
            INSTANCE = new ModConfig();
            me.shedaniel.autoconfig.AutoConfig.register(ModConfig.class, GsonConfigSerializer::new);
            INSTANCE = me.shedaniel.autoconfig.AutoConfig.getConfigHolder(ModConfig.class).getConfig();
        }
    }

    public static ModConfig getInstance() {
        if (INSTANCE == null) {
            load();
        }
        return INSTANCE;
    }
}

================
File: src/main/java/net/tockmod/entity/SnailSpawnManager.java
================
package net.tockmod.entity;

import net.minecraft.entity.EntityType;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.ChunkPos;
import net.tockmod.config.ModConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

public class SnailSpawnManager {
    private static final Logger LOGGER = LoggerFactory.getLogger("Tock/SnailSpawn");
    private final Map<ChunkPos, SpawnData> spawnDataMap = new ConcurrentHashMap<>();
    private final AtomicInteger spawnsThisTick = new AtomicInteger(0);

    public void onServerTickStart(MinecraftServer server) {
        if (!ModConfig.getInstance().snailspawnEnabled) {
            return;
        }

        // Reset spawn counter for new tick
        spawnsThisTick.set(0);
        LOGGER.debug("Reset spawn counter for new tick");
    }

    public void onServerTickEnd(MinecraftServer server) {
        // No-op for now
    }

    public boolean canSpawnEntity(ChunkPos pos, EntityType<?> entityType) {
        if (!ModConfig.getInstance().snailspawnEnabled) {
            return true;
        }

        // Check global spawn limit
        if (spawnsThisTick.get() >= ModConfig.getInstance().maxSpawnsPerTick) {
            LOGGER.debug("Spawn limit reached for this tick ({} entities)", ModConfig.getInstance().maxSpawnsPerTick);
            return false;
        }

        // Get or create spawn data for this chunk
        SpawnData data = spawnDataMap.computeIfAbsent(pos, k -> {
            LOGGER.debug("Created new spawn data for chunk {}", pos);
            return new SpawnData();
        });

        // Check entity type specific limits
        if (!data.canSpawnEntityType(entityType)) {
            LOGGER.debug("Entity type limit reached for {} in chunk {}", entityType, pos);
            return false;
        }

        // Increment spawn counters
        spawnsThisTick.incrementAndGet();
        data.recordSpawn(entityType);
        LOGGER.debug("Spawned {} in chunk {} (total this tick: {})", 
            entityType, 
            pos, 
            spawnsThisTick.get());
        return true;
    }

    private static class SpawnData {
        private final Map<EntityType<?>, Integer> entityTypeCounts = new ConcurrentHashMap<>();
        private static final int MAX_ENTITIES_PER_TYPE = 10;

        public boolean canSpawnEntityType(EntityType<?> type) {
            return entityTypeCounts.getOrDefault(type, 0) < MAX_ENTITIES_PER_TYPE;
        }

        public void recordSpawn(EntityType<?> type) {
            entityTypeCounts.merge(type, 1, Integer::sum);
        }
    }
}

================
File: src/main/java/net/tockmod/mixin/entity/MobMixin.java
================
package net.tockmod.mixin.entity;

import net.minecraft.entity.mob.MobEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.math.ChunkPos;
import net.tockmod.TockMod;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

@Mixin(MobEntity.class)
public class MobMixin {
    private static final Logger LOGGER = LoggerFactory.getLogger("Tock/Mixin/Mob");

    @Inject(method = "tick", at = @At("HEAD"), cancellable = true)
    private void onTickStart(CallbackInfo ci) {
        LOGGER.debug("Inject: onTickStart triggered for {}", this.getClass().getSimpleName());
        MobEntity mob = (MobEntity) (Object) this;
        
        // Skip ticking if the chunk is cold
        if (mob.getWorld() instanceof ServerWorld) {
            ServerWorld world = (ServerWorld) mob.getWorld();
            ChunkPos chunkPos = new ChunkPos(mob.getBlockPos());
            
            if (TockMod.getInstance().getChunkFuseManager().isChunkCold(chunkPos)) {
                LOGGER.debug("Skipping tick for mob {} in cold chunk {}", mob.getType(), chunkPos);
                ci.cancel();
            }
        } else {
            LOGGER.debug("Mob {} is not in a ServerWorld, skipping cold chunk check", mob.getType());
        }
    }
}

================
File: src/main/java/net/tockmod/mixin/entity/MobSpawnerMixin.java
================
package net.tockmod.mixin.entity;

import net.minecraft.entity.EntityType;
import net.minecraft.entity.SpawnReason;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.block.entity.MobSpawnerBlockEntity;
import net.tockmod.TockMod;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

@Mixin(MobSpawnerBlockEntity.class)
public class MobSpawnerMixin {
    @Inject(method = "spawnEntity", at = @At("HEAD"), cancellable = true)
    private void onSpawnEntity(ServerWorld world, BlockPos pos, EntityType<?> entityType, SpawnReason reason, CallbackInfoReturnable<Boolean> cir) {
        ChunkPos chunkPos = new ChunkPos(pos);
        
        // Check if we can spawn this entity
        if (!TockMod.getInstance().getSnailSpawnManager().canSpawnEntity(chunkPos, entityType)) {
            cir.setReturnValue(false);
            cir.cancel();
        }
    }
}

================
File: src/main/java/net/tockmod/mixin/server/ServerChunkManagerMixin.java
================
package net.tockmod.mixin.server;

import net.minecraft.server.world.ServerChunkManager;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.math.ChunkPos;
import net.tockmod.TockMod;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

@Mixin(ServerChunkManager.class)
public class ServerChunkManagerMixin {
    private static final Logger LOGGER = LoggerFactory.getLogger("Tock/Mixin/ChunkManager");

    @Inject(method = "tickChunks", at = @At("HEAD"))
    private void onTickChunksStart(CallbackInfo ci) {
        LOGGER.debug("Inject: onTickChunksStart triggered for {}", this.getClass().getSimpleName());
        ServerChunkManager manager = (ServerChunkManager) (Object) this;
        ServerWorld world = (ServerWorld) manager.getWorld();
        if (world == null) {
            LOGGER.error("Failed to retrieve ServerWorld in onTickChunksStart");
            return;
        }
        TockMod.getInstance().getChunkFuseManager().onServerTickStart(world.getServer());
    }

    @Inject(method = "tickChunks", at = @At("RETURN"))
    private void onTickChunksEnd(CallbackInfo ci) {
        LOGGER.debug("Inject: onTickChunksEnd triggered for {}", this.getClass().getSimpleName());
        ServerChunkManager manager = (ServerChunkManager) (Object) this;
        ServerWorld world = (ServerWorld) manager.getWorld();
        if (world == null) {
            LOGGER.error("Failed to retrieve ServerWorld in onTickChunksEnd");
            return;
        }
        TockMod.getInstance().getChunkFuseManager().onServerTickEnd(world.getServer());
    }

    @Inject(method = "tick", at = @At("HEAD"))
    private void onTickStart(CallbackInfo ci) {
        LOGGER.debug("Inject: onTickStart triggered for {}", this.getClass().getSimpleName());
        ServerChunkManager manager = (ServerChunkManager) (Object) this;
        ServerWorld world = (ServerWorld) manager.getWorld();
        if (world == null) {
            LOGGER.error("Failed to retrieve ServerWorld in onTickStart");
            return;
        }
        ChunkPos pos = new ChunkPos(world.getSpawnPos());
        TockMod.getInstance().getChunkFuseManager().markChunkActive(world, pos);
    }
}

================
File: src/main/java/net/tockmod/mixin/server/ServerTickSchedulerMixin.java
================
package net.tockmod.mixin.server;

import net.minecraft.server.MinecraftServer;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.world.tick.SimpleTickScheduler;
import net.minecraft.util.math.BlockPos;
import net.tockmod.TockMod;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

@Mixin(SimpleTickScheduler.class)
public class ServerTickSchedulerMixin {
    private static final Logger LOGGER = LoggerFactory.getLogger("Tock/Mixin/TickScheduler");
    private static int tickCount = 0;

    @Inject(method = "tick", at = @At("HEAD"))
    private void onTickStart(CallbackInfo ci) {
        LOGGER.debug("Inject: onTickStart triggered for {}", this.getClass().getSimpleName());
        MinecraftServer server = TockMod.getInstance().getServer();
        if (server == null) {
            LOGGER.error("Failed to retrieve MinecraftServer in onTickStart");
            return;
        }
        TockMod.getInstance().getSmartScheduler().onServerTickStart(server);
        
        // Log every 100 ticks
        if (++tickCount % 100 == 0) {
            LOGGER.debug("100 ticks passed in TickScheduler");
        }
    }

    @Inject(method = "tick", at = @At("RETURN"))
    private void onTickEnd(CallbackInfo ci) {
        LOGGER.debug("Inject: onTickEnd triggered for {}", this.getClass().getSimpleName());
        MinecraftServer server = TockMod.getInstance().getServer();
        if (server == null) {
            LOGGER.error("Failed to retrieve MinecraftServer in onTickEnd");
            return;
        }
        TockMod.getInstance().getSmartScheduler().onServerTickEnd(server);
    }

    @Inject(method = "scheduleTick", at = @At("HEAD"), cancellable = true)
    private void onScheduleTick(BlockPos pos, Object object, int delay, CallbackInfo ci) {
        LOGGER.debug("Inject: onScheduleTick triggered for {} at {}", this.getClass().getSimpleName(), pos);
        MinecraftServer server = TockMod.getInstance().getServer();
        if (server == null) {
            LOGGER.error("Failed to retrieve MinecraftServer in onScheduleTick");
            return;
        }

        // Get the overworld as our default world for scheduling
        ServerWorld world = server.getOverworld();
        if (world == null) {
            LOGGER.error("Failed to retrieve overworld in onScheduleTick");
            return;
        }

        // Use our smart scheduler instead
        TockMod.getInstance().getSmartScheduler().scheduleTask(world, pos, () -> {
            try {
                LOGGER.debug("Executing scheduled task at {}", pos);
                // Original tick logic would go here
            } catch (Exception e) {
                LOGGER.error("Task at {} failed: {}", pos, e.getMessage(), e);
            }
        }, delay);
        
        LOGGER.debug("Cancelling original scheduling for task at {}", pos);
        ci.cancel(); // Prevent the original scheduling
    }
}

================
File: src/main/java/net/tockmod/mixin/server/ServerWorldMixin.java
================
package net.tockmod.mixin.server;

import net.minecraft.server.world.ServerWorld;
import net.tockmod.TockMod;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

@Mixin(ServerWorld.class)
public class ServerWorldMixin {
    @Inject(method = "tick", at = @At("HEAD"))
    private void onTickStart(CallbackInfo ci) {
        ServerWorld world = (ServerWorld) (Object) this;
        TockMod.getInstance().getNeuroTickController().onServerTickStart(world.getServer());
    }

    @Inject(method = "tick", at = @At("RETURN"))
    private void onTickEnd(CallbackInfo ci) {
        ServerWorld world = (ServerWorld) (Object) this;
        TockMod.getInstance().getNeuroTickController().onServerTickEnd(world.getServer());
    }
}

================
File: src/main/java/net/tockmod/scheduler/SmartScheduler.java
================
package net.tockmod.scheduler;

import net.minecraft.server.MinecraftServer;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.math.BlockPos;
import net.tockmod.config.ModConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

public class SmartScheduler {
    private static final Logger LOGGER = LoggerFactory.getLogger("Tock/Scheduler");
    private final Queue<ScheduledTask> taskQueue = new PriorityQueue<>(Comparator.comparingInt(ScheduledTask::getPriority));
    private final Map<BlockPos, ScheduledTask> pendingTasks = new ConcurrentHashMap<>();
    private final AtomicLong lastTaskId = new AtomicLong(0);

    public void onServerTickStart(MinecraftServer server) {
        if (!ModConfig.getInstance().schedulerEnabled) {
            return;
        }

        // Process high priority tasks
        int processedTasks = processTasks(server);
        if (processedTasks > 0) {
            LOGGER.debug("Processed {} tasks in this tick", processedTasks);
        }
    }

    public void onServerTickEnd(MinecraftServer server) {
        // No-op for now
    }

    public void scheduleTask(ServerWorld world, BlockPos pos, Runnable task, int priority) {
        if (!ModConfig.getInstance().schedulerEnabled) {
            LOGGER.debug("Scheduler disabled, executing task immediately at {}", pos);
            task.run();
            return;
        }

        ScheduledTask scheduledTask = new ScheduledTask(
            lastTaskId.incrementAndGet(),
            world,
            pos,
            task,
            priority
        );

        // Check for redundant tasks
        if (ModConfig.getInstance().enablePreemptiveCancellation) {
            ScheduledTask existingTask = pendingTasks.get(pos);
            if (existingTask != null && existingTask.priority <= priority) {
                LOGGER.debug("Cancelling redundant task at {} (priority: {}, existing: {})", 
                    pos, 
                    priority, 
                    existingTask.priority);
                return;
            }
        }

        pendingTasks.put(pos, scheduledTask);
        taskQueue.offer(scheduledTask);
        LOGGER.debug("Scheduled task at {} with priority {} (queue size: {})", 
            pos, 
            priority, 
            taskQueue.size());
    }

    private int processTasks(MinecraftServer server) {
        int processedTasks = 0;
        while (!taskQueue.isEmpty() && processedTasks < 1000) { // Limit tasks per tick
            ScheduledTask task = taskQueue.poll();
            if (task != null) {
                LOGGER.debug("Executing task at {} with priority {}", task.pos, task.priority);
                task.run();
                pendingTasks.remove(task.pos);
                processedTasks++;
            }
        }
        return processedTasks;
    }

    private static class ScheduledTask implements Runnable {
        private final long id;
        private final ServerWorld world;
        private final BlockPos pos;
        private final Runnable task;
        private final int priority;

        public ScheduledTask(long id, ServerWorld world, BlockPos pos, Runnable task, int priority) {
            this.id = id;
            this.world = world;
            this.pos = pos;
            this.task = task;
            this.priority = priority;
        }

        @Override
        public void run() {
            task.run();
        }

        public int getPriority() {
            return priority;
        }
    }
}

================
File: src/main/java/net/tockmod/tick/NeuroTickController.java
================
package net.tockmod.tick;

import net.minecraft.server.MinecraftServer;
import net.tockmod.config.ModConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.atomic.AtomicLong;

public class NeuroTickController {
    private static final Logger LOGGER = LoggerFactory.getLogger("Tock/NeuroTick");
    private final AtomicLong lastTickTime = new AtomicLong(0);
    private final AtomicLong currentTickStart = new AtomicLong(0);
    private final RollingAverage tickTimeAverage = new RollingAverage(100);
    private boolean isOverBudget = false;

    public void onServerTickStart(MinecraftServer server) {
        if (!ModConfig.getInstance().neurotickEnabled) {
            return;
        }

        currentTickStart.set(System.nanoTime());
        
        // If we're over budget, reduce processing
        if (isOverBudget) {
            LOGGER.warn("Server is over tick budget (avg: {:.2f}ms), reducing processing", getAverageTickTime());
            // TODO: Implement tick reduction logic
        }
    }

    public void onServerTickEnd(MinecraftServer server) {
        if (!ModConfig.getInstance().neurotickEnabled) {
            return;
        }

        long tickTime = (System.nanoTime() - currentTickStart.get()) / 1_000_000; // Convert to milliseconds
        tickTimeAverage.add(tickTime);
        lastTickTime.set(tickTime);

        // Check if we're over budget
        isOverBudget = tickTime > ModConfig.getInstance().maxTickTime;
        
        if (isOverBudget) {
            LOGGER.warn("Tick took {}ms (budget: {}ms, avg: {:.2f}ms)", 
                tickTime, 
                ModConfig.getInstance().maxTickTime,
                getAverageTickTime());
        } else if (tickTime > ModConfig.getInstance().maxTickTime * 0.8) {
            LOGGER.info("Tick approaching budget limit: {}ms (budget: {}ms)", 
                tickTime, 
                ModConfig.getInstance().maxTickTime);
        }
    }

    public long getLastTickTime() {
        return lastTickTime.get();
    }

    public double getAverageTickTime() {
        return tickTimeAverage.getAverage();
    }

    public boolean isOverBudget() {
        return isOverBudget;
    }

    private static class RollingAverage {
        private final int size;
        private final double[] values;
        private int index = 0;
        private double sum = 0;

        public RollingAverage(int size) {
            this.size = size;
            this.values = new double[size];
        }

        public void add(double value) {
            sum -= values[index];
            values[index] = value;
            sum += value;
            index = (index + 1) % size;
        }

        public double getAverage() {
            return sum / size;
        }
    }
}

================
File: src/main/java/net/tockmod/TockMod.java
================
package net.tockmod;

import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents;
import net.minecraft.server.MinecraftServer;
import net.tockmod.config.ModConfig;
import net.tockmod.tick.NeuroTickController;
import net.tockmod.chunk.ChunkFuseManager;
import net.tockmod.entity.SnailSpawnManager;
import net.tockmod.scheduler.SmartScheduler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class TockMod implements ModInitializer {
    public static final String MOD_ID = "tock";
    public static final String MOD_VERSION = "1.0.0";
    public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);

    private static TockMod instance;
    private MinecraftServer server;
    private final NeuroTickController neuroTickController;
    private final ChunkFuseManager chunkFuseManager;
    private final SnailSpawnManager snailSpawnManager;
    private final SmartScheduler smartScheduler;

    public TockMod() {
        instance = this;
        
        // Initialize core systems
        this.neuroTickController = new NeuroTickController();
        this.chunkFuseManager = new ChunkFuseManager();
        this.snailSpawnManager = new SnailSpawnManager();
        this.smartScheduler = new SmartScheduler();
    }

    @Override
    public void onInitialize() {
        LOGGER.info("Initializing Tock - The Tick-Aware Orchestrator of Chunk Kinetics");
        LOGGER.info("Running Tock {} on Java {}", MOD_VERSION, System.getProperty("java.version"));
        
        // Load configuration
        ModConfig.load();
        
        // Register server lifecycle events
        ServerLifecycleEvents.SERVER_STARTED.register(server -> {
            this.server = server;
            LOGGER.info("Server started - Tock is now active");
        });

        ServerLifecycleEvents.SERVER_STOPPED.register(server -> {
            this.server = null;
            LOGGER.info("Server stopped - Tock is now inactive");
        });
        
        // Register tick events
        ServerTickEvents.START_SERVER_TICK.register(server -> {
            neuroTickController.onServerTickStart(server);
            chunkFuseManager.onServerTickStart(server);
            snailSpawnManager.onServerTickStart(server);
            smartScheduler.onServerTickStart(server);
        });

        ServerTickEvents.END_SERVER_TICK.register(server -> {
            neuroTickController.onServerTickEnd(server);
            chunkFuseManager.onServerTickEnd(server);
            snailSpawnManager.onServerTickEnd(server);
            smartScheduler.onServerTickEnd(server);
        });

        LOGGER.info("Tock initialization complete!");
    }

    public static TockMod getInstance() {
        return instance;
    }

    public MinecraftServer getServer() {
        if (server == null) {
            LOGGER.error("Server instance is null at this lifecycle point");
        }
        return server;
    }

    public NeuroTickController getNeuroTickController() {
        return neuroTickController;
    }

    public ChunkFuseManager getChunkFuseManager() {
        return chunkFuseManager;
    }

    public SnailSpawnManager getSnailSpawnManager() {
        return snailSpawnManager;
    }

    public SmartScheduler getSmartScheduler() {
        return smartScheduler;
    }
}

================
File: src/main/java/net/tockmod/TockServerMod.java
================
package net.tockmod;

import net.fabricmc.api.DedicatedServerModInitializer;
import net.fabricmc.fabric.api.command.v2.CommandRegistrationCallback;
import net.tockmod.command.TockCommands;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class TockServerMod implements DedicatedServerModInitializer {
    private static final Logger LOGGER = LoggerFactory.getLogger("Tock/Server");

    @Override
    public void onInitializeServer() {
        LOGGER.info("Initializing Tock Server Components");

        // Register commands
        CommandRegistrationCallback.EVENT.register((dispatcher, registryAccess, environment) -> {
            TockCommands.register(dispatcher);
        });

        LOGGER.info("Tock Server initialization complete!");
    }
}

================
File: src/main/resources/fabric.mod.json
================
{
  "schemaVersion": 1,
  "id": "tock",
  "version": "${version}",
  "name": "Tock",
  "description": "Tock makes every tick count.",
  "authors": [
    "Arnav Bonigala"
  ],
  "contact": {
    "email": "bonigala.arnav@gmail.com"
  },
  "license": "MIT",
  "icon": "assets/tock/icon.png",
  "environment": "server",
  "entrypoints": {
    "main": [
      "net.tockmod.TockMod"
    ],
    "server": [
      "net.tockmod.TockServerMod"
    ]
  },
  "mixins": [
    "tock.mixins.json"
  ],
  "depends": {
    "fabricloader": ">=0.15.10",
    "minecraft": "~1.21.5",
    "java": ">=21",
    "fabric-api": "*"
  }
}

================
File: src/main/resources/tock.mixins.json
================
{
  "required": true,
  "minVersion": "0.8",
  "package": "net.tockmod.mixin",
  "compatibilityLevel": "JAVA_21",
  "mixins": [
    "server.ServerWorldMixin",
    "server.ServerChunkManagerMixin",
    "server.ServerTickSchedulerMixin",
    "entity.MobSpawnerMixin",
    "entity.MobMixin"
  ],
  "client": [],
  "server": [
    "server.ServerWorldMixin",
    "server.ServerChunkManagerMixin",
    "server.ServerTickSchedulerMixin",
    "entity.MobSpawnerMixin",
    "entity.MobMixin"
  ],
  "injectors": {
    "defaultRequire": 1
  }
}

================
File: .gitignore
================
# Gradle
.gradle/
build/
out/
classes/

# IntelliJ IDEA
.idea/
*.iml
*.iws
*.ipr
out/

# VS Code
.vscode/
.settings/
.classpath
.project

# Eclipse
bin/
.metadata/

# Mac OS
.DS_Store

# Windows
Thumbs.db
ehthumbs.db
Desktop.ini

# Minecraft
run/
*.log
logs/
saves/
screenshots/

# Fabric
fabric-installer/
.minecraft/

================
File: build.gradle
================
plugins {
    id 'fabric-loom' version '1.10.1'
    id 'maven-publish'
}

version = "1.0.0"
group = "net.tockmod"
archivesBaseName = "tock"

repositories {
    gradlePluginPortal()
    // Add repositories to retrieve artifacts from in here.
    // You should only use this when depending on other mods because
    // Loom adds the essential maven repositories to download Minecraft and libraries from automatically.
    maven { url "https://maven.fabricmc.net/" }
    maven { url "https://maven.shedaniel.me/" }
    maven { url "https://maven.terraformersmc.com/" }
}

dependencies {
    // To change the versions see the gradle.properties file
    minecraft "com.mojang:minecraft:1.21.5"
    mappings "net.fabricmc:yarn:1.21.5+build.1:v2"
    modImplementation "net.fabricmc:fabric-loader:0.15.10"
    modImplementation "net.fabricmc.fabric-api:fabric-api:0.126.0+1.21.5"

    // Cloth Config for configuration
    modApi("me.shedaniel.cloth:cloth-config-fabric:13.0.121") {
        exclude(group: "net.fabricmc.fabric-api")
    }

    // Testing
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.2'
    testImplementation 'org.mockito:mockito-core:5.11.0'
}

processResources {
    inputs.property "version", project.version

    filesMatching("fabric.mod.json") {
        expand "version": project.version
    }
}

tasks.withType(JavaCompile).configureEach {
    it.options.release = 21
}

java {
    // Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
    // if it is present.
    // If you remove this line, sources will not be generated.
    withSourcesJar()
}

jar {
    from("LICENSE") {
        rename { "${it}_${project.archivesBaseName}"}
    }
}

// Configure the maven publication
publishing {
    publications {
        mavenJava(MavenPublication) {
            artifact(remapJar) {
                builtBy remapJar
            }
            artifact(sourcesJar) {
                builtBy remapSourcesJar
            }
        }
    }
}

test {
    useJUnitPlatform()
}

================
File: gradle.properties
================
# Done to increase the memory available to gradle.
org.gradle.jvmargs=-Xmx1G
org.gradle.parallel=true

# Fabric Properties
minecraft_version=1.21.5
yarn_mappings=1.21.5+build.1
loader_version=0.15.10

# Mod Properties
mod_version=1.0.0
maven_group=net.tockmod
archives_base_name=tock

# Dependencies
fabric_version=0.95.0+1.21.5

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Arnav Bonigala

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# Tock: The Tick-Aware Orchestrator of Chunk Kinetics

A server-side-only Fabric mod that brings adaptive, low-overhead tick scheduling, dynamic chunk prioritization, and CPU-budget-aware execution to the Minecraft server tick loop.

## Features

### 🧠 NeuroTick – Tick Budget Governor
- Prevents lag spikes by distributing heavy workloads across multiple ticks
- Maintains a cost profile per tick task type
- Implements a low-cost PID-style controller for adapting to server load

### 🔳 ChunkFuse – Adaptive Chunk Activity Graph
- Only ticks what players actually see, use, or influence
- Builds a lightweight visibility + usage graph of loaded chunks
- Marks chunks as "cold" when inactive

### 🐌 SnailSpawn – Controlled Entity Spawning
- Fine-tuned, lag-free mob spawning
- Per-entity-type spawn queues with load-aware delay injection
- Area-specific spawn pacing

### 🧱 BlockCache – High-Speed Read-Only Block Data
- Safe API for plugins to inspect chunks without loading them
- Creates an async, tick-updated cache of blockstates
- No chunk loads, no memory explosions

## Requirements

- Minecraft 1.21.5
- Fabric Loader 0.15.10+
- Fabric API 0.95.0+
- Java 21+

## Installation

1. Install [Fabric Loader](https://fabricmc.net/use/)
2. Download the latest release from the [releases page](https://github.com/tockmod/tock/releases)
3. Place the jar file in your server's `mods` folder
4. Start your server

## Configuration

Tock can be configured through the `config/tock.json5` file. The following options are available:

```json5
{
  "neurotick": {
    "enabled": true,
    "maxTickTime": 40
  },
  "chunkfuse": {
    "enabled": true,
    "chunkColdTimeout": 30
  },
  "snailspawn": {
    "enabled": true,
    "maxSpawnsPerTick": 10
  },
  "scheduler": {
    "enabled": true,
    "enablePreemptiveCancellation": true
  }
}
```

## Commands

- `/tock debug` - Shows current tick statistics
- `/tock profile` - Shows performance profiling data
- `/tock heatmap` - Shows chunk activity heatmap

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Fabric Team for the amazing modding platform
- The Minecraft community for inspiration and feedback

================
File: settings.gradle
================
pluginManagement {
    repositories {
        maven { url "https://maven.fabricmc.net/" }
        gradlePluginPortal()
    }
}

rootProject.name = "tock"




================================================================
End of Codebase
================================================================
